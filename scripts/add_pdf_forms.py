#!/usr/bin/env python3
"""
Add interactive AcroForm fields to PDF documents.

Post-processes PDFs generated by MkDocs to add fillable form fields
(checkboxes, radio buttons, text inputs) at positions matching visual elements.

Detection Strategy:
- Checkboxes: Search for literal "[ ]" patterns in PDF text
- Radio buttons: Search for literal "( )" patterns in PDF text
- Text fields: Detect empty table cells using PyMuPDF table detection

Widgets are placed directly over the pattern text with white backgrounds
to create clean, interactive form controls.
"""

import argparse
import sys
from pathlib import Path
from typing import NamedTuple

try:
    import fitz  # PyMuPDF
except ImportError:
    print("Error: PyMuPDF not installed. Run: pip install PyMuPDF")
    sys.exit(1)

# Try to enable pymupdf-layout for better table detection
HAS_LAYOUT = False
try:
    import pymupdf.layout
    pymupdf.layout.activate()
    HAS_LAYOUT = True
except (ImportError, AttributeError):
    pass


class FormField(NamedTuple):
    """Represents a form field to be added."""
    field_type: str  # 'checkbox', 'radio', 'text'
    name: str
    rect: fitz.Rect
    group: str = None  # For radio button grouping


# Widget styling constants
WIDGET_PADDING = 1  # Small padding around the pattern
MIN_WIDGET_SIZE = 10  # Minimum widget dimension


def find_checkbox_patterns(page: fitz.Page) -> list[FormField]:
    """
    Find [ ] patterns on a page and create checkbox fields at those positions.

    The checkbox widget is placed directly over the [ ] text to cover it.
    """
    fields = []
    page_num = page.number

    # Search for literal "[ ]" pattern (checkbox indicator)
    checkbox_rects = page.search_for("[ ]")

    for idx, rect in enumerate(checkbox_rects):
        # Expand rect slightly for better widget coverage
        widget_rect = fitz.Rect(
            rect.x0 - WIDGET_PADDING,
            rect.y0 - WIDGET_PADDING,
            rect.x1 + WIDGET_PADDING,
            rect.y1 + WIDGET_PADDING
        )

        # Ensure minimum size
        if widget_rect.width < MIN_WIDGET_SIZE:
            center_x = (widget_rect.x0 + widget_rect.x1) / 2
            widget_rect.x0 = center_x - MIN_WIDGET_SIZE / 2
            widget_rect.x1 = center_x + MIN_WIDGET_SIZE / 2
        if widget_rect.height < MIN_WIDGET_SIZE:
            center_y = (widget_rect.y0 + widget_rect.y1) / 2
            widget_rect.y0 = center_y - MIN_WIDGET_SIZE / 2
            widget_rect.y1 = center_y + MIN_WIDGET_SIZE / 2

        # Ensure widget is within page bounds
        widget_rect = widget_rect & page.rect

        if widget_rect.is_empty or widget_rect.width < 5 or widget_rect.height < 5:
            continue

        fields.append(FormField(
            field_type='checkbox',
            name=f'cb_p{page_num}_n{idx}',
            rect=widget_rect
        ))

    return fields


def find_radio_patterns(page: fitz.Page) -> list[FormField]:
    """
    Find ( ) patterns on a page and create radio button fields at those positions.

    Radio buttons on the same row (similar Y coordinates) are grouped together.
    The radio widget is placed directly over the ( ) text to cover it.
    """
    fields = []
    page_num = page.number

    # Search for literal "( )" pattern (radio button indicator)
    radio_rects = page.search_for("( )")

    # Group by Y-coordinate (same row = same group)
    # Round Y to nearest 10px to group items on the same line
    row_groups = {}

    for idx, rect in enumerate(radio_rects):
        row_key = round(rect.y0 / 10) * 10
        if row_key not in row_groups:
            row_groups[row_key] = []
        row_groups[row_key].append((idx, rect))

    # Create fields with group assignments
    for row_key, items in row_groups.items():
        group_name = f'rg_p{page_num}_y{int(row_key)}'

        for idx, rect in items:
            # Expand rect slightly for better widget coverage
            widget_rect = fitz.Rect(
                rect.x0 - WIDGET_PADDING,
                rect.y0 - WIDGET_PADDING,
                rect.x1 + WIDGET_PADDING,
                rect.y1 + WIDGET_PADDING
            )

            # Ensure minimum size
            if widget_rect.width < MIN_WIDGET_SIZE:
                center_x = (widget_rect.x0 + widget_rect.x1) / 2
                widget_rect.x0 = center_x - MIN_WIDGET_SIZE / 2
                widget_rect.x1 = center_x + MIN_WIDGET_SIZE / 2
            if widget_rect.height < MIN_WIDGET_SIZE:
                center_y = (widget_rect.y0 + widget_rect.y1) / 2
                widget_rect.y0 = center_y - MIN_WIDGET_SIZE / 2
                widget_rect.y1 = center_y + MIN_WIDGET_SIZE / 2

            # Ensure widget is within page bounds
            widget_rect = widget_rect & page.rect

            if widget_rect.is_empty or widget_rect.width < 5 or widget_rect.height < 5:
                continue

            fields.append(FormField(
                field_type='radio',
                name=f'rb_p{page_num}_n{idx}',
                rect=widget_rect,
                group=group_name
            ))

    return fields


def find_text_fields_pattern(page: fitz.Page) -> list[FormField]:
    """
    Find ___ patterns on a page using text search (fallback method).

    The text widget is placed directly over the ___ text to cover it,
    similar to how checkboxes cover [ ] and radios cover ( ).
    """
    fields = []
    page_num = page.number

    # Search for literal "___" pattern (text input indicator)
    # This matches 3 or more underscores used as a fill-in-the-blank marker
    text_rects = page.search_for("___")

    for idx, rect in enumerate(text_rects):
        # Expand the widget horizontally to provide more input space
        # Keep vertical size close to the text height
        widget_rect = fitz.Rect(
            rect.x0 - WIDGET_PADDING,
            rect.y0 - WIDGET_PADDING,
            rect.x1 + 50,  # Extend right for more input space
            rect.y1 + WIDGET_PADDING
        )

        # Ensure minimum height for usability
        if widget_rect.height < 14:
            center_y = (widget_rect.y0 + widget_rect.y1) / 2
            widget_rect.y0 = center_y - 7
            widget_rect.y1 = center_y + 7

        # Ensure widget is within page bounds
        widget_rect = widget_rect & page.rect

        if widget_rect.is_empty or widget_rect.width < 20 or widget_rect.height < 10:
            continue

        fields.append(FormField(
            field_type='text',
            name=f'tf_p{page_num}_n{idx}',
            rect=widget_rect
        ))

    return fields


def find_text_fields_table_cells(page: fitz.Page) -> list[FormField]:
    """
    Find ___ patterns using table cell rectangles for better text field sizing.

    When pymupdf-layout is available, this function uses table.cells to get
    precise cell boundaries, allowing text fields to fill the entire cell
    rather than just extending from the pattern position.
    """
    fields = []
    page_num = page.number
    field_count = 0

    try:
        tables = page.find_tables()
        if not tables or not tables.tables:
            return find_text_fields_pattern(page)

        for table in tables.tables:
            content = table.extract()
            cells = getattr(table, 'cells', None)

            if not cells or not content:
                continue

            cell_idx = 0
            for row_idx, row in enumerate(content):
                for col_idx, cell_text in enumerate(row):
                    if cell_idx < len(cells):
                        # Check if cell contains ___ pattern
                        if cell_text and '___' in str(cell_text):
                            cell_rect = cells[cell_idx]
                            # cell_rect is (x0, y0, x1, y1) tuple
                            widget_rect = fitz.Rect(
                                cell_rect[0] + 2,  # Small padding from left
                                cell_rect[1] + 2,  # Small padding from top
                                cell_rect[2] - 2,  # Small padding from right
                                cell_rect[3] - 2   # Small padding from bottom
                            )

                            # Ensure minimum dimensions
                            if widget_rect.width < 30:
                                widget_rect.x1 = widget_rect.x0 + 30
                            if widget_rect.height < 14:
                                center_y = (widget_rect.y0 + widget_rect.y1) / 2
                                widget_rect.y0 = center_y - 7
                                widget_rect.y1 = center_y + 7

                            # Ensure widget is within page bounds
                            widget_rect = widget_rect & page.rect

                            if not widget_rect.is_empty and widget_rect.width >= 20 and widget_rect.height >= 10:
                                fields.append(FormField(
                                    field_type='text',
                                    name=f'tf_p{page_num}_r{row_idx}_c{col_idx}',
                                    rect=widget_rect
                                ))
                                field_count += 1
                    cell_idx += 1

    except Exception:
        # Fall back to pattern-based detection on any error
        return find_text_fields_pattern(page)

    # If no fields found via table cells, fall back to pattern detection
    if field_count == 0:
        return find_text_fields_pattern(page)

    return fields


def find_text_fields(page: fitz.Page) -> list[FormField]:
    """
    Find ___ patterns on a page and create text input fields.

    Uses table cell detection when pymupdf-layout is available for better
    field sizing, otherwise falls back to pattern-based detection.
    """
    if HAS_LAYOUT:
        return find_text_fields_table_cells(page)
    else:
        return find_text_fields_pattern(page)


def add_checkbox_widget(page: fitz.Page, field: FormField) -> None:
    """Add a checkbox widget to the page, covering the [ ] pattern."""
    widget = fitz.Widget()
    widget.field_type = fitz.PDF_WIDGET_TYPE_CHECKBOX
    widget.field_name = field.name
    widget.rect = field.rect
    widget.field_value = False
    widget.border_color = (0.31, 0.45, 1.0)  # F5 blue #4F73FF
    widget.border_width = 1
    widget.fill_color = (1, 1, 1)  # White background to cover [ ]

    page.add_widget(widget)


def add_radio_widget(page: fitz.Page, field: FormField) -> None:
    """Add a radio button widget to the page, covering the ( ) pattern."""
    widget = fitz.Widget()
    widget.field_type = fitz.PDF_WIDGET_TYPE_RADIOBUTTON
    widget.field_name = field.group if field.group else field.name
    widget.rect = field.rect
    widget.field_value = False
    widget.border_color = (0.31, 0.45, 1.0)  # F5 blue
    widget.border_width = 1
    widget.fill_color = (1, 1, 1)  # White background to cover ( )

    page.add_widget(widget)


def add_text_widget(page: fitz.Page, field: FormField) -> None:
    """Add a text input widget to the page, filling an empty table cell."""
    widget = fitz.Widget()
    widget.field_type = fitz.PDF_WIDGET_TYPE_TEXT
    widget.field_name = field.name
    widget.rect = field.rect
    widget.field_value = ""
    widget.text_color = (0, 0, 0)  # Black text
    widget.border_color = (0.8, 0.8, 0.8)  # Light gray border
    widget.border_width = 1
    widget.fill_color = (1, 1, 1)  # White background
    widget.text_fontsize = 10

    page.add_widget(widget)


def process_pdf(input_path: Path, output_path: Path, verbose: bool = False) -> dict:
    """
    Process a PDF to add interactive form fields.

    Returns a dict with counts: {'checkboxes': n, 'radios': n, 'text_fields': n, 'total': n}
    """
    import tempfile
    import shutil

    doc = fitz.open(input_path)
    stats = {'checkboxes': 0, 'radios': 0, 'text_fields': 0, 'total': 0}

    for page_num, page in enumerate(doc):
        # Find form field positions using pattern detection
        checkboxes = find_checkbox_patterns(page)
        radios = find_radio_patterns(page)
        text_fields = find_text_fields(page)

        page_widgets = 0

        # Add checkbox widgets
        for field in checkboxes:
            try:
                add_checkbox_widget(page, field)
                stats['checkboxes'] += 1
                stats['total'] += 1
                page_widgets += 1
            except Exception as e:
                if verbose:
                    print(f"Warning: Could not add checkbox on page {page_num + 1}: {e}")

        # Add radio button widgets
        for field in radios:
            try:
                add_radio_widget(page, field)
                stats['radios'] += 1
                stats['total'] += 1
                page_widgets += 1
            except Exception as e:
                if verbose:
                    print(f"Warning: Could not add radio on page {page_num + 1}: {e}")

        # Add text field widgets
        for field in text_fields:
            try:
                add_text_widget(page, field)
                stats['text_fields'] += 1
                stats['total'] += 1
                page_widgets += 1
            except Exception as e:
                if verbose:
                    print(f"Warning: Could not add text field on page {page_num + 1}: {e}")

        if verbose and page_widgets > 0:
            print(f"  Page {page_num + 1}: {len(checkboxes)} checkboxes, "
                  f"{len(radios)} radios, {len(text_fields)} text fields")

    # Save to temp file first, then move (handles same input/output path)
    same_file = input_path.resolve() == output_path.resolve()
    if same_file:
        with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp:
            tmp_path = Path(tmp.name)
        doc.save(tmp_path, garbage=4, deflate=True)
        doc.close()
        shutil.move(tmp_path, output_path)
    else:
        doc.save(output_path, garbage=4, deflate=True)
        doc.close()

    return stats


def process_directory(input_dir: Path, verbose: bool = False) -> dict:
    """
    Process all PDF files in a directory.

    Returns aggregated stats dict.
    """
    total_stats = {'checkboxes': 0, 'radios': 0, 'text_fields': 0, 'total': 0, 'files': 0}
    pdf_files = list(input_dir.rglob('*.pdf'))

    for pdf_path in pdf_files:
        print(f"Processing: {pdf_path}")
        try:
            stats = process_pdf(pdf_path, pdf_path, verbose)
            for key in ['checkboxes', 'radios', 'text_fields', 'total']:
                total_stats[key] += stats[key]
            total_stats['files'] += 1
            print(f"  Added {stats['total']} form fields "
                  f"({stats['checkboxes']} checkboxes, {stats['radios']} radios, "
                  f"{stats['text_fields']} text fields)")
        except Exception as e:
            print(f"  Error processing {pdf_path}: {e}")

    return total_stats


def main():
    parser = argparse.ArgumentParser(
        description='Add interactive form fields to PDF documents',
        epilog='''
Detection Strategy:
  - Checkboxes: Searches for "[ ]" patterns in PDF text
  - Radio buttons: Searches for "( )" patterns in PDF text
  - Text fields: Detects empty cells in PDF tables

Widgets are placed directly over pattern text with white backgrounds.
        '''
    )
    parser.add_argument(
        '--input', '-i',
        type=Path,
        help='Input PDF file path'
    )
    parser.add_argument(
        '--output', '-o',
        type=Path,
        help='Output PDF file path (defaults to overwriting input)'
    )
    parser.add_argument(
        '--input-dir',
        type=Path,
        help='Process all PDFs in directory recursively'
    )
    parser.add_argument(
        '--markdown-dir',
        type=Path,
        help='Markdown documentation directory (optional, for future enhancement)'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Verbose output showing per-page details'
    )

    args = parser.parse_args()

    if args.input_dir:
        # Process directory
        if not args.input_dir.exists():
            print(f"Error: Directory not found: {args.input_dir}")
            sys.exit(1)

        stats = process_directory(args.input_dir, args.verbose)
        print(f"\nProcessed {stats['files']} files")
        print(f"Total form fields added: {stats['total']}")
        print(f"  Checkboxes: {stats['checkboxes']}")
        print(f"  Radio buttons: {stats['radios']}")
        print(f"  Text fields: {stats['text_fields']}")

    elif args.input:
        # Process single file
        if not args.input.exists():
            print(f"Error: File not found: {args.input}")
            sys.exit(1)

        output_path = args.output if args.output else args.input
        stats = process_pdf(args.input, output_path, args.verbose)
        print(f"Added {stats['total']} form fields to {output_path}")
        print(f"  Checkboxes: {stats['checkboxes']}")
        print(f"  Radio buttons: {stats['radios']}")
        print(f"  Text fields: {stats['text_fields']}")

    else:
        parser.print_help()
        sys.exit(1)


if __name__ == '__main__':
    main()
